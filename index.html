<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MR Kamui Art Museum</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background: #000;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #mr-button {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px 40px;
            font-size: 20px;
            font-weight: bold;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
            transition: all 0.3s ease;
            z-index: 10;
        }

        #mr-button:hover {
            transform: translate(-50%, -50%) scale(1.05);
            box-shadow: 0 15px 40px rgba(102, 126, 234, 0.6);
        }

        #mr-button:active {
            transform: translate(-50%, -50%) scale(0.98);
        }

        #mr-button.hidden {
            display: none;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            z-index: 5;
        }

        #loading.hidden {
            display: none;
        }

        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="loading">モデルを読み込み中...</div>
    <button id="mr-button" class="hidden">MRを起動</button>
    <div id="info">マウスドラッグで回転 • ホイールでズーム</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { ARButton } from 'three/addons/webxr/ARButton.js';
        import { XRButton } from 'three/addons/webxr/XRButton.js';

        let scene, camera, renderer, controls;
        let model;
        let xrSession = null;
        let leftController = null;
        let rightController = null;
        let yButtonPressed = false;
        let xButtonPressed = false;
        let initialControllerPosition = null;
        let initialScale = null;
        let initialModelPosition = null;

        // シーンの初期化
        function init() {
            const container = document.getElementById('canvas-container');

            // シーン作成
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);

            // カメラ設定
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 2, 5);

            // レンダラー設定
            renderer = new THREE.WebGLRenderer({
                antialias: true,
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;

            // WebXR有効化
            renderer.xr.enabled = true;

            container.appendChild(renderer.domElement);

            // オービットコントロール
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.target.set(0, 0, 0);

            // ライティング設定
            setupLighting();

            // GLBモデル読み込み
            loadModel();

            // MRボタンの設定
            setupMRButton();

            // リサイズ対応
            window.addEventListener('resize', onWindowResize);
        }

        // ライティング設定
        function setupLighting() {
            // 環境光
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            // ディレクショナルライト（太陽光）
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.near = 0.1;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -10;
            directionalLight.shadow.camera.right = 10;
            directionalLight.shadow.camera.top = 10;
            directionalLight.shadow.camera.bottom = -10;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // ポイントライト
            const pointLight1 = new THREE.PointLight(0xffd700, 0.5, 10);
            pointLight1.position.set(-3, 3, 3);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0x00bfff, 0.5, 10);
            pointLight2.position.set(3, 3, -3);
            scene.add(pointLight2);

            // スポットライト
            const spotLight = new THREE.SpotLight(0xffffff, 0.5);
            spotLight.position.set(0, 8, 0);
            spotLight.angle = Math.PI / 4;
            spotLight.penumbra = 0.3;
            spotLight.decay = 2;
            spotLight.distance = 30;
            spotLight.castShadow = true;
            scene.add(spotLight);
        }

        // モデル読み込み
        function loadModel() {
            const loader = new GLTFLoader();
            const loadingElement = document.getElementById('loading');
            const mrButton = document.getElementById('mr-button');

            loader.load(
                './AstroRoom.glb',
                function(gltf) {
                    model = gltf.scene;

                    // モデルの設定
                    model.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });

                    // スケール調整（5倍に拡大）
                    const box = new THREE.Box3().setFromObject(model);
                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const scale = 15 / maxDim; // 12から15に変更して5倍のサイズ
                    model.scale.multiplyScalar(scale);

                    // 中心に配置
                    const center = box.getCenter(new THREE.Vector3());
                    model.position.sub(center.multiplyScalar(scale));

                    scene.add(model);

                    // UI更新
                    loadingElement.classList.add('hidden');
                    mrButton.classList.remove('hidden');
                },
                function(xhr) {
                    const percentComplete = (xhr.loaded / xhr.total) * 100;
                    loadingElement.textContent = `モデルを読み込み中... ${Math.round(percentComplete)}%`;
                },
                function(error) {
                    console.error('モデル読み込みエラー:', error);
                    loadingElement.textContent = 'モデルの読み込みに失敗しました';
                }
            );
        }

        // MRボタン設定
        async function setupMRButton() {
            const mrButton = document.getElementById('mr-button');

            // WebXRサポートチェック（詳細ログ付き）
            console.log('WebXRサポートチェック開始');
            console.log('navigator.xr:', !!navigator.xr);

            if ('xr' in navigator) {
                try {
                    const arSupported = await navigator.xr.isSessionSupported('immersive-ar');
                    const vrSupported = await navigator.xr.isSessionSupported('immersive-vr');

                    console.log('AR対応:', arSupported);
                    console.log('VR対応:', vrSupported);
                    console.log('User Agent:', navigator.userAgent);

                    if (arSupported) {
                        mrButton.addEventListener('click', onMRButtonClick);
                        console.log('MRボタンを有効化しました');
                    } else if (vrSupported) {
                        mrButton.textContent = 'VRを起動';
                        mrButton.addEventListener('click', onVRButtonClick);
                        console.log('VRボタンを有効化しました');
                    } else {
                        mrButton.textContent = 'XR非対応';
                        mrButton.disabled = true;
                        console.log('XRが対応していません');
                    }
                } catch (error) {
                    console.error('WebXRサポートチェック中にエラー:', error);
                    mrButton.textContent = 'エラー';
                    mrButton.disabled = true;
                }
            } else {
                console.log('navigator.xrが存在しません');
                mrButton.textContent = 'WebXR非対応';
                mrButton.disabled = true;
            }
        }

        // MRボタンクリック
        async function onMRButtonClick() {
            const mrButton = document.getElementById('mr-button');

            if (xrSession) {
                await xrSession.end();
                xrSession = null;
                mrButton.textContent = 'MRを起動';
                return;
            }

            try {
                console.log('MRセッション開始を試行中...');

                // WebXRサポートの詳細チェック
                if (!navigator.xr) {
                    throw new Error('WebXRがサポートされていません');
                }

                const arSupported = await navigator.xr.isSessionSupported('immersive-ar');
                console.log('ARサポート確認:', arSupported);

                if (!arSupported) {
                    throw new Error('ARモードがサポートされていません');
                }

                console.log('ARセッション要求中...');
                xrSession = await navigator.xr.requestSession('immersive-ar', {
                    requiredFeatures: ['local'],
                    optionalFeatures: ['hit-test', 'dom-overlay'],
                    domOverlay: { root: document.body }
                });

                console.log('ARセッション作成成功:', xrSession);

                renderer.xr.setReferenceSpaceType('local');
                await renderer.xr.setSession(xrSession);

                // コントローラーの設定
                setupControllers();

                // MR開始時にモデルをプレイヤーの目の前に配置
                if (model) {
                    model.position.set(0, -1.6, -10); // 前方10m、プレイヤーの足元（床面）に配置
                    model.rotation.y = 0; // 正面を向くように回転をリセット

                    // MRモード時はメッシュを両面表示に設定
                    model.traverse((child) => {
                        if (child.isMesh && child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(mat => mat.side = THREE.DoubleSide);
                            } else {
                                child.material.side = THREE.DoubleSide;
                            }
                        }
                    });
                }

                mrButton.textContent = 'MRを終了';

                xrSession.addEventListener('end', () => {
                    xrSession = null;
                    mrButton.textContent = 'MRを起動';
                    // MR終了時に元の位置に戻す
                    if (model) {
                        // マテリアルを片面表示に戻す
                        model.traverse((child) => {
                            if (child.isMesh && child.material) {
                                if (Array.isArray(child.material)) {
                                    child.material.forEach(mat => mat.side = THREE.FrontSide);
                                } else {
                                    child.material.side = THREE.FrontSide;
                                }
                            }
                        });

                        const box = new THREE.Box3().setFromObject(model);
                        const center = box.getCenter(new THREE.Vector3());
                        const size = box.getSize(new THREE.Vector3());
                        const maxDim = Math.max(size.x, size.y, size.z);
                        const scale = 15 / maxDim; // 5倍サイズに合わせて15に変更
                        model.position.sub(center.multiplyScalar(scale));
                    }
                });

            } catch (error) {
                console.error('MRセッション開始エラー:', error);
                let errorMessage = 'MRモードの起動に失敗しました';

                if (error.message.includes('WebXR')) {
                    errorMessage += '\nWebXRに対応したブラウザが必要です（Chrome、Edge等）';
                } else if (error.message.includes('ARモード')) {
                    errorMessage += '\nARモードに対応したデバイスが必要です';
                } else {
                    errorMessage += `\nエラー詳細: ${error.message}`;
                }

                alert(errorMessage);
            }
        }

        // VRボタンクリック（フォールバック）
        async function onVRButtonClick() {
            const mrButton = document.getElementById('mr-button');

            if (xrSession) {
                await xrSession.end();
                xrSession = null;
                mrButton.textContent = 'VRを起動';
                return;
            }

            try {
                xrSession = await navigator.xr.requestSession('immersive-vr');

                renderer.xr.setReferenceSpaceType('local');
                await renderer.xr.setSession(xrSession);

                mrButton.textContent = 'VRを終了';

                xrSession.addEventListener('end', () => {
                    xrSession = null;
                    mrButton.textContent = 'VRを起動';
                });

            } catch (error) {
                console.error('VRセッション開始エラー:', error);
                alert('VRモードの起動に失敗しました');
            }
        }

        // コントローラーの設定
        function setupControllers() {
            // 左コントローラー（インデックス0）
            leftController = renderer.xr.getController(0);
            scene.add(leftController);

            // 右コントローラー（インデックス1）
            rightController = renderer.xr.getController(1);
            scene.add(rightController);

            console.log('コントローラーを設定しました');
        }

        // コントローラー入力の処理
        function handleControllerInput() {
            if (!xrSession || !model) return;

            const session = renderer.xr.getSession();
            if (!session || !session.inputSources) return;

            session.inputSources.forEach((inputSource, index) => {
                if (!inputSource.gamepad) return;

                // 左コントローラー（通常インデックス0）
                if (inputSource.handedness === 'left' || index === 0) {
                    const gamepad = inputSource.gamepad;
                    // Xボタンは通常ボタンインデックス2
                    const xButton = gamepad.buttons[2];
                    // Yボタンは通常ボタンインデックス3
                    const yButton = gamepad.buttons[3];

                    // 左スティック入力（axes[2]が横軸、axes[3]が縦軸）
                    if (gamepad.axes && gamepad.axes.length >= 4) {
                        const stickX = gamepad.axes[2]; // 左右（-1:左、1:右）
                        const stickY = gamepad.axes[3]; // 上下（-1:上、1:下）

                        // デッドゾーンを設定（微小な入力を無視）
                        const deadzone = 0.1;

                        // 現在のXRカメラの位置と向きを取得
                        const xrCamera = renderer.xr.getCamera();

                        // スティックで方向転換（左右）
                        if (Math.abs(stickX) > deadzone) {
                            const rotationSpeed = 0.02; // 回転速度
                            const rotationAngle = -stickX * rotationSpeed;

                            // カメラのリファレンススペースを取得して回転を適用
                            const referenceSpace = renderer.xr.getReferenceSpace();
                            if (referenceSpace) {
                                // Y軸回転のクォータニオンを作成
                                const halfAngle = rotationAngle / 2;
                                const transform = new XRRigidTransform(
                                    { x: 0, y: 0, z: 0, w: 1 },
                                    {
                                        x: 0,
                                        y: Math.sin(halfAngle),
                                        z: 0,
                                        w: Math.cos(halfAngle)
                                    }
                                );
                                const newReferenceSpace = referenceSpace.getOffsetReferenceSpace(transform);
                                renderer.xr.setReferenceSpace(newReferenceSpace);
                            }
                        }

                        // スティックで前後移動（上下）
                        if (Math.abs(stickY) > deadzone) {
                            const moveSpeed = 0.1; // 移動速度

                            // XRカメラの向きから前方ベクトルを計算
                            const cameraMatrix = xrCamera.matrixWorld;
                            const forward = new THREE.Vector3();
                            cameraMatrix.extractBasis(new THREE.Vector3(), new THREE.Vector3(), forward);

                            // Y成分を0にして水平移動のみにする
                            forward.y = 0;
                            forward.normalize();

                            // 移動量を計算（スティックは下が正なので符号反転）
                            const movement = forward.multiplyScalar(-stickY * moveSpeed);

                            // カメラのリファレンススペースを移動
                            const referenceSpace = renderer.xr.getReferenceSpace();
                            if (referenceSpace) {
                                const transform = new XRRigidTransform(
                                    { x: movement.x, y: 0, z: movement.z, w: 1 },
                                    { x: 0, y: 0, z: 0, w: 1 }
                                );
                                const newReferenceSpace = referenceSpace.getOffsetReferenceSpace(transform);
                                renderer.xr.setReferenceSpace(newReferenceSpace);
                            }
                        }
                    }

                    // Xボタン - 位置移動
                    if (xButton && xButton.pressed) {
                        if (!xButtonPressed) {
                            // Xボタンが押された瞬間
                            xButtonPressed = true;
                            initialControllerPosition = leftController.position.clone();
                            initialModelPosition = model.position.clone();
                            console.log('Xボタン押下開始 - 位置移動モード');
                        } else {
                            // Xボタンを押し続けている間
                            const currentPos = leftController.position;
                            // コントローラーの移動量を計算
                            const deltaX = currentPos.x - initialControllerPosition.x;
                            const deltaY = currentPos.y - initialControllerPosition.y;
                            const deltaZ = currentPos.z - initialControllerPosition.z;

                            // モデルの位置を更新（移動感度を調整）
                            const movementScale = 3; // 移動感度
                            model.position.x = initialModelPosition.x + deltaX * movementScale;
                            model.position.y = initialModelPosition.y + deltaY * movementScale;
                            model.position.z = initialModelPosition.z + deltaZ * movementScale;
                        }
                    } else if (xButtonPressed) {
                        // Xボタンが離された
                        xButtonPressed = false;
                        console.log('Xボタン離した - 位置確定:', model.position);
                    }

                    // Yボタン - スケール調整
                    if (yButton && yButton.pressed) {
                        if (!yButtonPressed) {
                            // Yボタンが押された瞬間
                            yButtonPressed = true;
                            initialControllerPosition = leftController.position.clone();
                            initialScale = model.scale.clone();
                            console.log('Yボタン押下開始 - スケール調整モード');
                        } else {
                            // Yボタンを押し続けている間
                            const currentPos = leftController.position;
                            // 上下の動きでスケール調整（上で拡大、下で縮小）
                            const deltaY = currentPos.y - initialControllerPosition.y;
                            const scaleFactor = 1 + deltaY * 2; // スケール変化係数

                            // スケールを0.1倍から10倍の範囲に制限
                            const newScale = Math.max(0.1, Math.min(10, scaleFactor));
                            model.scale.copy(initialScale).multiplyScalar(newScale);
                        }
                    } else if (yButtonPressed) {
                        // Yボタンが離された
                        yButtonPressed = false;
                        console.log('Yボタン離した - スケール確定:', model.scale.x);
                    }
                }
            });
        }

        // ウィンドウリサイズ
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // アニメーションループ
        function animate() {
            renderer.setAnimationLoop(render);
        }

        function render() {
            // モデルを回転
            if (model && !xrSession) {
                model.rotation.y += 0.002;
            }

            if (controls && !xrSession) {
                controls.update();
            }

            // XRセッション中はコントローラー入力を処理
            if (xrSession) {
                handleControllerInput();
            }

            renderer.render(scene, camera);
        }

        // 初期化と開始
        init();
        animate();
    </script>
</body>
</html>